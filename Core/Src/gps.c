//
// Created by wenwe on 2021/2/13.
//

#include <gps.h>
#include <stdio.h>


void debug(int val) {
    if (val) {
        HAL_Delay(0);
    }
}

#define TO_INT(ch_prev, ch_next) \
    ('0' <= (ch_prev) && (ch_prev) <= '9' ? (ch_prev - '0') : (ch_prev) - 'A' + 10) * 16 + \
    ('0' <= (ch_next) && (ch_next) <= '9' ? (ch_next - '0') : (ch_next) - 'A' + 10)

GPSInfo gps_read() {
    uint8_t data;
    while (1) {
        HAL_UART_Receive(&huart3, &data, 1, 100);
        if (data == '$') break;
    }
    char buffer[128] = {0};
    int index = 0;
    while (1) {
        HAL_UART_Receive(&huart3, &data, 1, 100);
        if (data == '\r') break;
        buffer[index++] = data;
        if (index == 128) break;
    }
    GPSInfo info = gps_parse(buffer);
    if (info.valid) {
        __NOP();
    }
    __NOP();
    return info;
}

void gps_mode_close(enum GPS_MSG type) {
    switch (type) {
        case GPDTM: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x44, 0x54, 0x4d, 0x2a, 0x33, 0x42, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x0a, 0x00, 0x04, 0x23};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGBS: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x42, 0x53, 0x2a, 0x33, 0x30, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x09, 0x00, 0x03, 0x21};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGGA: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x47, 0x41, 0x2a, 0x32, 0x37, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x00, 0x00, 0xfa, 0x0f};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGLL: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x4c, 0x4c, 0x2a, 0x32, 0x31, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x01, 0x00, 0xfb, 0x11};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGRS: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x52, 0x53, 0x2a, 0x32, 0x30, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x06, 0x00, 0x00, 0x1b};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGSA: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x53, 0x41, 0x2a, 0x33, 0x33, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x02, 0x00, 0xfc, 0x13};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGST: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x53, 0x54, 0x2a, 0x32, 0x36, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x07, 0x00, 0x01, 0x1d};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGSV: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x53, 0x56, 0x2a, 0x32, 0x34, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x03, 0x00, 0xfd, 0x15};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPRMC: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x52, 0x4d, 0x43, 0x2a, 0x33, 0x41, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x04, 0x00, 0xfe, 0x17};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPVTG: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x56, 0x54, 0x47, 0x2a, 0x32, 0x33, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x05, 0x00, 0xff, 0x19};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPZDA: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x5a, 0x44, 0x41, 0x2a, 0x33, 0x39, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x08, 0x00, 0x02, 0x1f};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        default:
            break;
    }
    uint8_t save_cmd[] = {
            0xb5, 0x62, 0x06, 0x09, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x07, 0x21, 0xaf,
    };
    HAL_UART_Transmit(&huart3, save_cmd, sizeof(save_cmd), 1000);
}

void gps_mode_open(enum GPS_MSG type) {
    switch (type) {
        case GPDTM: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x44, 0x54, 0x4d, 0x2a, 0x33, 0x42, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x0a, 0x01, 0x05, 0x24};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGBS: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x42, 0x53, 0x2a, 0x33, 0x30, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x09, 0x01, 0x04, 0x22};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGGA: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x47, 0x41, 0x2a, 0x32, 0x37, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x00, 0x01, 0xfb, 0x10};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGLL: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x4c, 0x4c, 0x2a, 0x32, 0x31, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x01, 0x01, 0xfc, 0x12};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGRS: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x52, 0x53, 0x2a, 0x32, 0x30, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x06, 0x01, 0x01, 0x1c};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGSA: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x53, 0x41, 0x2a, 0x33, 0x33, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x02, 0x01, 0xfd, 0x14};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGST: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x53, 0x54, 0x2a, 0x32, 0x36, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x07, 0x01, 0x02, 0x1e};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPGSV: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x47, 0x53, 0x56, 0x2a, 0x32, 0x34, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x03, 0x01, 0xfe, 0x16};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPRMC: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x52, 0x4d, 0x43, 0x2a, 0x33, 0x41, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x04, 0x01, 0xff, 0x18};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPVTG: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x56, 0x54, 0x47, 0x2a, 0x32, 0x33, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x05, 0x01, 0x00, 0x1a};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        case GPZDA: {
            uint8_t cmd[] = {0x24, 0x45, 0x49, 0x47, 0x50, 0x51, 0x2c, 0x5a, 0x44, 0x41, 0x2a, 0x33, 0x39, 0x0d, 0x0a,
                             0xb5, 0x62, 0x06, 0x01, 0x03, 0x00, 0xf0, 0x08, 0x01, 0x03, 0x20};
            HAL_UART_Transmit(&huart3, cmd, sizeof(cmd), 1000);
        }
            break;
        default:
            break;
    }
    uint8_t save_cmd[] = {
            0xb5, 0x62, 0x06, 0x09, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x07, 0x21, 0xaf,
    };
    HAL_UART_Transmit(&huart3, save_cmd, sizeof(save_cmd), 1000);
}

GPSInfo gps_parse(const char *raw_data) {
    GPSInfo result = {0};
    const char* id = "GNGGA";
    for (int i = 0; i < 5; ++i) {
        if (raw_data[i] != id[i]) {
            result.valid = 0;
            return result;
        }
    }
    // checksum
    uint8_t xor_sum = 0;
    uint8_t msg_sum = 0;
    for (int i = 0; i < 126; ++i) {
        if (raw_data[i] == '*') {
            msg_sum = TO_INT(raw_data[i + 1], raw_data[i + 2]);
            break;
        }
        xor_sum ^= raw_data[i];
    }
    // invalid msg
    if (msg_sum != xor_sum) {
        result.valid = 0;
        return result;
    }

    char buffer[16] = {0};
    int raw_index = 6, now_index;
    // ignore time
    while (raw_index < 128 && raw_data[raw_index] != ',') ++raw_index; // ignore time
    ++raw_index; // ,

    // parse latitude
    now_index = 0;
    while (raw_index < 128 && raw_data[raw_index] != ',') {
        buffer[now_index++] = raw_data[raw_index];
        ++raw_index;
    }
    if (now_index == 0) {
        // no info
        result.valid = 0;
        return result;
    }

    buffer[now_index] = 0;
    sscanf(buffer, "%f", &result.latitude);
    result.latitude /= 100.f;
    ++raw_index;  // ','
    ++raw_index;  // 'N'
    ++raw_index;  // ','

    // parse longitude
    now_index = 0;
    while (raw_index < 128 && raw_data[raw_index] != ',') {
        buffer[now_index++] = raw_data[raw_index];
        ++raw_index;
        if (now_index == 16) break;
    }
    buffer[now_index] = 0;
    sscanf(buffer, "%f", &result.longitude);
    result.longitude /= 100.f;
    ++raw_index; // ,
    ++raw_index; // E
    ++raw_index; // ,

    while (raw_index < 128 && raw_data[raw_index] != ',') ++raw_index; // gps mode
    ++raw_index;

    // parse n_satellites
    result.n_satellites = 0;
    while (raw_index < 128 && raw_data[raw_index] != ',') {
        result.n_satellites = result.n_satellites * 10 + raw_data[raw_index] - '0';
        ++raw_index;
    }
    ++raw_index;
    while (raw_index < 128 && raw_data[raw_index] != ',') ++raw_index; // quality
    ++raw_index;

    // parse height
    now_index = 0;
    while (raw_index < 128 && raw_data[raw_index] != ',') {
        buffer[now_index++] = raw_data[raw_index];
        ++raw_index;
    }
    buffer[now_index] = 0;
    sscanf(buffer, "%f", &result.height);
    result.valid = 1;
    return result;
}

